C51 COMPILER V9.60.7.0   LOW_ENERGY                                                        08/11/2025 16:39:38 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LOW_ENERGY
OBJECT MODULE PLACED IN .\Release\Objects\low_energy.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\low_energy.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C)
                    - INCDIR(..\..\Libraries\Include;..\..\User;..\..\HardWare) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\low_e
                    -nergy.lst) OBJECT(.\Release\Objects\low_energy.obj)

line level    source

   1          #include "low_energy.h"
   2          
   3          void sleep_in(void)
   4          {
   5   1          SYS_CON6 |= SYS_MPDN_CNT(0x3);     // 关闭程序存储器供电的延迟时间配置4个系统周期
   6   1          SYS_CON7 = (SYS_EXT_SLP_CNT(0x3) | // 退出低功耗延迟的时间配置各配四个系统周期
   7   1                      SYS_MTPUP_CNT(0x3) |
   8   1                      SYS_OPM_LDO_CNT(0x3) |
   9   1                      SYS_CLSM_LDO_CNT(0x3));
  10   1          SYS_CON8 |= SYS_LPSLP_DIS_ANA(0x1);   // 打开低功耗sleep mode一键关模拟模块功能(即关
             -TK,AMP,CMP,ADC之类的模块)
  11   1          CLK_XOSC &= ~(CLK_XOSC_LOW_EN(0x1) |  // 关闭32.768KHz低速晶振
  12   1                        CLK_XOSC_HIGH_EN(0x1)); // 关闭高速晶振
  13   1          LVD_CON0 &= ~(LVD_VCC_DETE_EN(0x1) |  // 关闭VCC电源VCC电压低电检测功能
  14   1                        LVD_VDD_DETE_EN(0x1));  // 关闭1.5V数字逻辑系统工作电压VDD低电检测功能
  15   1          PMU_CON2 &= ~0x70;                    // 关闭VPTAT_ADC输出，关闭温度传感器输出VPTAT，
             -LDO过流档位选择50mA
  16   1          CLK_CON0 &= ~CLK_SYSCLK_SEL(0x3);     // 系统时钟选择rc64k
  17   1          FLASH_TIMEREG1 = 0x0;                 // 配置LIRC时FLASH访问速度
  18   1          PMU_CON0 &= ~0x60;                    // 关闭VDD POR模块, 关闭VBG06_REF输出
  19   1          CLK_ACON0 &= ~CLK_AIP_HRC_EN(0x1);    // 关闭HRC时钟
  20   1          LP_CON = (LP_IDLE_EN(0x1) |
  21   1                    LP_SLEEP_GO_EN(0x1) | // Sleep低功耗模式唤醒后继续跑后续程序
  22   1                    LP_GLIRC_EN(0x1) |    // 关闭RC64K低速时钟
  23   1                    LP_SLEEP_EN(0x1));    // 使能睡眠
  24   1      }
  25          
  26          void sleep_out(void)
  27          {
  28   1          SYS_CON8 &= ~SYS_LPSLP_DIS_ANA(0x1); // 关闭低功耗sleep mode一键关模拟模块功能(即打开
             -TK,AMP,CMP,ADC之类的模块)
  29   1          PMU_CON0 |= 0x60;                    // 使能VDD POR模块，使能VBG06_REF输出
  30   1          LVD_CON0 |= (LVD_VCC_DETE_EN(0x1) |  // 使能VCC电源VCC电压低电检测功能
  31   1                       LVD_VDD_DETE_EN(0x1));  // 使能1.5V数字逻辑系统工作电压VDD低电检测功能
  32   1          PMU_CON2 |= 0x70;                    // 使能VPTAT_ADC输出，使能温度传感器输出VPTAT，主
             -LDO过流档位选择100mA
  33   1          CLK_ACON0 |= CLK_AIP_HRC_EN(0x1);    // 使能HRC时钟
  34   1          // LP_WKPND |= LP_WKUP_0_PCLR(0x1);     // 清除通道0唤醒标志位
  35   1      
  36   1          LP_WKPND |= LP_WKUP_0_PCLR(0x01) | LP_WKUP_1_PCLR(0x01); // 清除唤醒通道0唤醒标志位，清
             -唤醒通道1唤醒标志位
  37   1      
  38   1          FLASH_TIMEREG1 = 0x58;           // FLASH访问速度 = 系统时钟/3
  39   1          CLK_CON0 |= CLK_SYSCLK_SEL(0x3); // 系统时钟选择hirc_clk
  40   1      }
  41          
  42          // 低功耗
  43          void low_energy(void)
  44          {
  45   1          // #define WUT_PERIOD_VAL (SYSCLK / 64 / 3000 - 1)
  46   1      
  47   1          bit flag_is_really_wake_up = 0; // 标志位，是否真的要唤醒
  48   1      
C51 COMPILER V9.60.7.0   LOW_ENERGY                                                        08/11/2025 16:39:38 PAGE 2   

  49   1          if (CUR_LED_MODE_OFF != cur_led_mode || /* 指示灯没有关闭 */
  50   1              0 != cur_light_pwm_duty_val)        /* 主灯光的占空比不为0 */
  51   1          {
  52   2              // 不满足进入低功耗的条件，退出
  53   2              return;
  54   2          }
  55   1      
  56   1          // printf("begin sleep\n");
  57   1      
  58   1          // 低功耗模式下配置所有的IO端口为模拟输入模式
  59   1          P0_MD0 = 0xFF;
  60   1          P0_MD1 = 0xFF;
  61   1          P1_MD0 = 0xFF;
  62   1          P1_MD1 = 0xFF;
  63   1          P2_MD0 = 0xFF;
  64   1          P2_MD1 = 0xFF;
  65   1          P3_MD0 = 0xFF;
  66   1          P3_MD1 = 0xFF;
  67   1      
  68   1      // 关闭不使用的片上外设
  69   1      #if USE_MY_DEBUG
  70   1          UART0_CON0 &= ~UART_EN(0x01); // 不使能uart0 
  71   1      #endif
  72   1          // __DisableIRQ(TMR0_IRQn); // 关闭中断
  73   1          // TMR0_CONL &= ~( (0x07 << 5) | (0x03 << 0)); // 清空计数源配置，清空计数模式配置--
             -使能计数
  74   1          // TMR0_CONL |= (0x05 << 5); // 不选择计数源--无计数源
  75   1          TMR0_CONL &= ~(0x03 << 0); // 清空计数模式配置--不使能计数
  76   1          TMR1_CONL &= ~(0x03 << 0); // 清空计数模式配置--不使能计数
  77   1          TMR2_CONL &= ~(0x03 << 0); // 清空计数模式配置--不使能计数
  78   1      
  79   1          ADC_CFG0 &= ~((0x01 << 6) | (0x01 << 3)); // 不使能adc，不使能通道0转换功能
  80   1          AMP_CON11 &= ~(0x01 << 0);                // 不使能 pga0
  81   1      
  82   1          // 控制充电的引脚，输出低电平
  83   1          // P2_MD1 &= ~GPIO_P26_MODE_SEL(0x03);
  84   1          // P2_MD1 |= GPIO_P26_MODE_SEL(0x01); // 输出模式
  85   1          // P26 = 0;
  86   1      
  87   1          // 控制主灯光的引脚，输出电平
  88   1      
  89   1          // P17是烧录引脚，没调用IO_MAP关闭烧录功能情况下需要将此引脚上拉
  90   1          // P1_PU |= GPIO_P17_PULL_UP(0x1);
  91   1      
  92   1          while (0 == flag_is_really_wake_up) // 如果不是真的被唤醒，则回到低功耗
  93   1          {
  94   2      
  95   2              // printf("sleep\n");
  96   2              /*
  97   2                  配置唤醒源，
  98   2                  红外接收，有低电平就唤醒，连接到唤醒通道0
  99   2                  充电电压 大于 4.9V 唤醒
 100   2      
 101   2                  使用定时唤醒，唤醒后检测一次充电电压，如果小于4.9V，回到低功耗
 102   2              */
 103   2              // 红外接收引脚：
 104   2              P2_PU |= GPIO_P23_PULL_UP(0x01);      // 上拉
 105   2              P2_MD0 &= ~(GPIO_P23_MODE_SEL(0x03)); // 输入模式
 106   2              FIN_S10 = 0x14;                       // 唤醒通道0选择 红外接收引脚
 107   2      
 108   2              // 充电电压检测引脚配置为输入模式，关闭上下拉
 109   2              P2_PU &= ~GPIO_P25_PULL_UP(0x01);   // 关闭上拉
C51 COMPILER V9.60.7.0   LOW_ENERGY                                                        08/11/2025 16:39:38 PAGE 3   

 110   2              P2_PD &= ~GPIO_P25_PULL_PD(0x01);   // 关闭下拉
 111   2              P2_MD1 &= ~GPIO_P25_MODE_SEL(0x03); // 输入模式
 112   2      
 113   2              FIN_S11 = 0x16; // 唤醒通道1 选择 P25 作为唤醒源
 114   2      
 115   2      #if 0
                  // 配置定时唤醒：
                  // 设置WUT的计数功能，配置一个3000ms的中断
                  // __EnableIRQ(WUT_IRQn);         // 使能WUT中断
                  IE_EA = 1;                     // 使能总中断
                  // TMR_ALLCON = WUT_CNT_CLR(0x1); // 清除计数值
              // WUT_PRH = TMR_PERIOD_VAL_H(((3000 - 1) >> 8) & 0xFF); // 周期值
              // WUT_PRL = TMR_PERIOD_VAL_L(((3000 - 1) >> 0) & 0xFF);
                  WUT_PRH = TMR_PERIOD_VAL_H((WUT_PERIOD_VAL >> 8) & 0xFF); // 周期值
                  WUT_PRL = TMR_PERIOD_VAL_L((WUT_PERIOD_VAL >> 0) & 0xFF);
                  WUT_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // 使能唤醒定时器
                  WUT_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x6) | TMR_MODE_SEL(0x1); // 选择系统时钟，64
             -分频，计数模式
              #endif
 128   2      
 129   2              LP_CON &= ~LP_ISD_DIS_LP_EN(0x01); // 使能ISD模式下低功耗功能
 130   2              LP_WKPND = LP_WKUP_0_PCLR(0x01) |  /* 清除唤醒标志位 */
 131   2                         LP_WKUP_1_PCLR(0x1);    /* 清除唤醒标志位 */
 132   2              // LP_WKCON = (LP_WKUP_0_EDG(0x01) |  /* 通道0低电平触发唤醒 */
 133   2              //             LP_WKUP_0_EN(0x01) |   /* 唤醒通道0使能 */
 134   2              //             LP_WKUP_2_EDG(0x00) |  /* 通道2高电平触发唤醒 */
 135   2              //             LP_WKUP_2_EN(0x01));   /* 唤醒通道2使能（WUT唤醒只能是唤醒通道2） 
             -*/
 136   2      
 137   2              LP_WKCON = LP_WKUP_0_EDG(0x01) | /* 通道0低电平触发唤醒 */
 138   2                         LP_WKUP_0_EN(0x01) |  /* 唤醒通道0使能 */
 139   2                         LP_WKUP_1_EDG(0x00) | /* 通道1高电平触发唤醒 */
 140   2                         LP_WKUP_1_EN(0x01);   /* 唤醒通道1使能 */
 141   2      
 142   2              sleep_in();
 143   2              sleep_out();
 144   2      
 145   2              /* 唤醒后，关闭唤醒源 */
 146   2              LP_WKCON &= ~(LP_WKUP_0_EN(0x01) | LP_WKUP_1_EN(0x01)); // 不使能唤醒通道0，不使能唤
             -通道1
 147   2      
 148   2              // 如果不是红外信号唤醒 或是 充电电压小于4.9V，重新回到低功耗
 149   2              if (0 == P23)
 150   2              {
 151   3                  flag_is_really_wake_up = 1;
 152   3      
 153   3                  // uart0_config();
 154   3                  // printf("ir wake up\n");
 155   3                  continue; // 提前退出，防止红外解码失败
 156   3              }
 157   2      
 158   2              adc_config();
 159   2              adc_update_charge_adc_val(ADC_REF_2_0_VOL);                      // adc使用2V参考电压，更
             - charging_adc_val 的数值
 160   2              if (charging_adc_val >= (u16)((u32)4900 * 4096 / 11 / 2 / 1000)) // 如果此时充电电压小于
             -4.9V
 161   2              {
 162   3                  flag_is_really_wake_up = 1;
 163   3      
 164   3                  // uart0_config();
 165   3                  // printf("charge wake up\n");
 166   3                  continue;
C51 COMPILER V9.60.7.0   LOW_ENERGY                                                        08/11/2025 16:39:38 PAGE 4   

 167   3              }
 168   2          }
 169   1      
 170   1          // printf("wake up\n");
 171   1      
 172   1          // 唤醒后，需要重新初始化系统
 173   1          user_init();
 174   1      
 175   1          // printf("wake up\n");
 176   1      }
 177          
 178          // 使用了WUT中断唤醒，必须要加上对应的中断服务函数
 179          // void WUT_IRQHandler(void) interrupt WUT_IRQn
 180          // {
 181          //     // 进入中断设置IP，不可删除
 182          //     __IRQnIPnPush(WUT_IRQn);
 183          
 184          //     // ---------------- 用户函数处理 -------------------
 185          
 186          //     // 周期中断
 187          //     if(WUT_CONH & TMR_PRD_PND(0x1)) {
 188          //         WUT_CONH |=  TMR_PRD_PND(0x1);          // 清除pending
 189          
 190          //     }
 191          
 192          //     // 退出中断设置IP，不可删除
 193          //     __IRQnIPnPop(WUT_IRQn);
 194          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    291    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
